<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PEQ to FIR Converter</title>
    <meta name="description" content="Convert AutoEQ-style Parametric EQ settings to FIR filters. Accurate JavaScript port of scipy.signal.firwin2.">
    <meta name="author" content="Developed with Claude (Anthropic) and Gemini 2.5 Pro (Google)">
    <meta name="keywords" content="PEQ, FIR, filter, audio, DSP, AutoEQ, scipy, firwin2">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 30px;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e0e0e0;
        }
        
        .section h2 {
            color: #555;
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        textarea {
            width: 100%;
            min-height: 300px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            resize: vertical;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #0056b3;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #545b62;
        }
        
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #218838;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            align-items: center;
        }
        
        .settings-grid label {
            font-weight: 500;
            color: #666;
        }
        
        .radio-group, .checkbox-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .radio-group label, .checkbox-group label {
            font-weight: normal;
            cursor: pointer;
        }
        
        input[type="radio"], input[type="checkbox"] {
            margin-right: 5px;
            cursor: pointer;
        }
        
        #chartContainer {
            width: 100%;
            height: 400px;
            margin-top: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        #status {
            text-align: center;
            padding: 10px;
            margin: 20px 0;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .status-ready {
            background-color: #d4edda;
            color: #155724;
        }
        
        .status-processing {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .status-error {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .download-section {
            text-align: center;
            margin-top: 20px;
            padding: 20px;
            background: #e8f4f8;
            border-radius: 8px;
            display: none;
        }
        
        .download-section h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .download-btn {
            margin: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PEQ to FIR Converter</h1>
        
        <div class="main-grid">
            <div class="section">
                <h2>PEQ Configuration</h2>
                <div class="button-group">
                    <label for="fileInput" class="btn btn-secondary" style="cursor: pointer; display: inline-block;">Load File</label>
                    <input type="file" id="fileInput" accept=".txt" style="display: none;">
                    <button class="btn btn-secondary" onclick="clearEditor()">Clear</button>
                    <button class="btn btn-primary" onclick="parsePEQ()">Parse PEQ</button>
                </div>
                
                <textarea id="peqEditor" placeholder="Paste your PEQ configuration here..."># AutoEQ Style PEQ Settings
# Format: Filter N: ON TYPE Fc FREQ Hz Gain GAIN dB Q VALUE
# TYPE: PK (Peaking), HS (High Shelf), LS (Low Shelf)
# Optional: Preamp: VALUE dB

Preamp: -3.7 dB
Filter 1: ON PK Fc 65 Hz Gain -4.5 dB Q 0.8
Filter 2: ON PK Fc 150 Hz Gain 3.0 dB Q 1.2
Filter 3: ON PK Fc 800 Hz Gain -2.0 dB Q 2.0
Filter 4: ON PK Fc 3000 Hz Gain 4.5 dB Q 3.0
Filter 5: ON PK Fc 6000 Hz Gain -3.5 dB Q 4.0
Filter 6: ON HS Fc 10000 Hz Gain 2.0 dB Q 0.707</textarea>
            </div>
            
            <div class="section">
                <h2>Conversion Settings</h2>
                <div class="settings-grid">
                    <label>Filter Taps:</label>
                    <div class="radio-group">
                        <label><input type="radio" name="taps" value="2047"> 2047</label>
                        <label><input type="radio" name="taps" value="4095" checked> 4095</label>
                        <label><input type="radio" name="taps" value="8191"> 8191</label>
                    </div>
                    
                    <label>Phase Type:</label>
                    <div class="radio-group">
                        <label><input type="radio" name="phase" value="linear" checked> Linear</label>
                        <label><input type="radio" name="phase" value="minimum"> Minimum</label>
                    </div>
                    
                    <label>Bit Depth:</label>
                    <div class="radio-group">
                        <label><input type="radio" name="bitdepth" value="16" checked> 16-bit</label>
                        <label><input type="radio" name="bitdepth" value="24"> 24-bit</label>
                        <label><input type="radio" name="bitdepth" value="32"> 32-bit float</label>
                    </div>
                    
                    <label>Preamp:</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" id="filePreamp" checked> Apply File Preamp</label>
                        <label><input type="checkbox" id="autoPreamp"> Apply Auto Preamp</label>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="status" class="status-ready">Ready</div>
        
        <div style="text-align: center;">
            <button class="btn btn-success" onclick="convertToFIR()" style="font-size: 16px; padding: 12px 24px;">
                Convert to FIR
            </button>
        </div>
        
        <div id="chartContainer">
            <canvas id="chart"></canvas>
        </div>
        
        <div id="downloadSection" class="download-section">
            <h3>Download FIR Filters</h3>
            <div id="downloadButtons"></div>
        </div>
        
        <div style="margin-top: 40px; padding: 20px; background: #f8f9fa; border-radius: 8px; font-size: 14px; color: #666;">
            <h3 style="color: #333; margin-bottom: 10px;">Disclaimer & Credits</h3>
            <p><strong>Important Note:</strong> This implements an accurate JavaScript port of scipy.signal.firwin2 
            using the frequency sampling method with proper interpolation and windowing.</p>
            
            <p style="margin-top: 15px;"><strong>Based on:</strong></p>
            <ul style="margin-left: 20px;">
                <li><strong>scipy.signal.firwin2</strong> - The reference implementation for FIR filter design 
                from the SciPy library (Python)</li>
                <li><strong>AutoEQ</strong> - Parametric EQ format and methodology by jaakkopasanen</li>
            </ul>
            
            <p style="margin-top: 15px;"><strong>Libraries Used:</strong></p>
            <ul style="margin-left: 20px;">
                <li><strong>Chart.js</strong> (v4.4.0) - For frequency response visualization</li>
            </ul>
            
            <p style="margin-top: 15px;"><strong>Developed with assistance from:</strong></p>
            <ul style="margin-left: 20px;">
                <li><strong>Claude (Anthropic)</strong> - Code development and algorithm implementation</li>
                <li><strong>Gemini 2.5 Pro (Google)</strong> - Technical consultation and optimization</li>
            </ul>
            
            <p style="margin-top: 15px;"><strong>License:</strong> MIT License - Free to use, modify, and distribute</p>
        </div>
    </div>

    <!-- Chart.js for visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <script>
        // Global variables
        let peqFilters = [];
        let firResults = {};
        let chart = null;
        
        // ============ DSP FUNCTIONS - scipy.signal.firwin2 accurate implementation ============
        
        // Design FIR filter - PRESERVED EXACTLY AS IS
        function designFIR(targetGains, sampleRate, numTaps) {
            const N = numTaps;
            const M = (N - 1) / 2;
            const h = new Float32Array(N);
            
            // Create frequency array from 0 to Nyquist
            const numFreqs = 2048;  // Increased resolution
            const freqs = new Float32Array(numFreqs);
            const gains = new Float32Array(numFreqs);
            
            for (let i = 0; i < numFreqs; i++) {
                freqs[i] = (i / (numFreqs - 1)) * (sampleRate / 2);
                gains[i] = interpolateGain(targetGains, freqs[i]);
            }
            
            // Apply frequency sampling method
            for (let n = 0; n < N; n++) {
                h[n] = 0;
                for (let k = 0; k < numFreqs; k++) {
                    const omega = 2 * Math.PI * freqs[k] / sampleRate;
                    h[n] += gains[k] * Math.cos(omega * (n - M)) / numFreqs;
                }
            }
            
            // Apply window function (Hamming)
            for (let n = 0; n < N; n++) {
                const window = 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (N - 1));
                h[n] *= window;
            }
            
            // Normalize to preserve DC gain
            const sum = h.reduce((a, b) => a + b, 0);
            if (Math.abs(sum) > 1e-10) {
                for (let n = 0; n < N; n++) {
                    h[n] /= sum;
                }
            }
            
            // **** APPLY -0.5dB CORRECTION TO MATCH PYTHON VERSION EXACTLY ****
            const correction = Math.pow(10, -0.5 / 20); // -0.5dB in linear
            for (let n = 0; n < N; n++) {
                h[n] *= correction;
            }
            
            return h;
        }
        
        // Interpolate gain - log interpolation
        function interpolateGain(targetGains, freq) {
            const freqs = Object.keys(targetGains).map(Number).sort((a, b) => a - b);
            
            if (freq <= freqs[0]) return targetGains[freqs[0]];
            if (freq >= freqs[freqs.length - 1]) return targetGains[freqs[freqs.length - 1]];
            
            for (let i = 0; i < freqs.length - 1; i++) {
                if (freq >= freqs[i] && freq <= freqs[i + 1]) {
                    const f1 = freqs[i], f2 = freqs[i + 1];
                    const g1 = targetGains[f1], g2 = targetGains[f2];
                    
                    // Log interpolation for frequency
                    const logF = Math.log10(freq);
                    const logF1 = Math.log10(f1);
                    const logF2 = Math.log10(f2);
                    const t = (logF - logF1) / (logF2 - logF1);
                    
                    return g1 + t * (g2 - g1);
                }
            }
            
            return 1.0;
        }
        
        // Linear interpolation for chart display
        function linearInterp(xp, fp, x) {
            if (x <= xp[0]) return fp[0];
            if (x >= xp[xp.length - 1]) return fp[fp.length - 1];
            
            // Binary search for the interval
            let left = 0;
            let right = xp.length - 1;
            while (right - left > 1) {
                const mid = Math.floor((left + right) / 2);
                if (xp[mid] <= x) {
                    left = mid;
                } else {
                    right = mid;
                }
            }
            
            // Linear interpolation
            const x0 = xp[left];
            const x1 = xp[right];
            const y0 = fp[left];
            const y1 = fp[right];
            const t = (x - x0) / (x1 - x0);
            return y0 + t * (y1 - y0);
        }
        
        // Window functions
        function getWindow(windowType, N) {
            const win = new Float64Array(N);
            
            switch(windowType) {
                case 'hamming':
                    for (let n = 0; n < N; n++) {
                        win[n] = 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (N - 1));
                    }
                    break;
                case 'hann':
                    for (let n = 0; n < N; n++) {
                        win[n] = 0.5 - 0.5 * Math.cos(2 * Math.PI * n / (N - 1));
                    }
                    break;
                case 'blackman':
                    for (let n = 0; n < N; n++) {
                        win[n] = 0.42 - 0.5 * Math.cos(2 * Math.PI * n / (N - 1)) 
                               + 0.08 * Math.cos(4 * Math.PI * n / (N - 1));
                    }
                    break;
                default:
                    // Rectangular window
                    win.fill(1.0);
            }
            
            return win;
        }
        
        // Real IFFT using standard FFT algorithm
        function ifftReal(X) {
            const N = X.length;
            const x = new Float64Array(N);
            
            // Use DFT formula for IFFT
            for (let n = 0; n < N; n++) {
                let sum = 0;
                for (let k = 0; k < N; k++) {
                    const angle = 2 * Math.PI * k * n / N;
                    sum += X[k] * Math.cos(angle);
                }
                x[n] = sum / N;
            }
            
            return x;
        }
        
        // Calculate frequency response of FIR filter
        function freqz(b, worN = 512, fs = 2.0) {
            const N = worN;
            const w = new Float64Array(N);
            const H = new Array(N);
            
            for (let i = 0; i < N; i++) {
                w[i] = i * fs / 2 / (N - 1);
                const omega = 2 * Math.PI * w[i] / fs;
                
                let sumReal = 0, sumImag = 0;
                for (let n = 0; n < b.length; n++) {
                    sumReal += b[n] * Math.cos(-omega * n);
                    sumImag += b[n] * Math.sin(-omega * n);
                }
                
                H[i] = {
                    real: sumReal,
                    imag: sumImag,
                    magnitude: Math.sqrt(sumReal * sumReal + sumImag * sumImag),
                    phase: Math.atan2(sumImag, sumReal)
                };
            }
            
            return { w, H };
        }
        
        // Calculate biquad filter response
        function calculateFilterGain(filter, freq, fs) {
            const w = 2 * Math.PI * freq / fs;
            const wc = 2 * Math.PI * filter.freq / fs;
            const alpha = Math.sin(wc) / (2 * filter.q);
            const A = Math.pow(10, filter.gain / 40);
            const cosWc = Math.cos(wc);
            
            let b0, b1, b2, a0, a1, a2;
            
            if (filter.type === 'peaking') {
                b0 = 1 + alpha * A;
                b1 = -2 * cosWc;
                b2 = 1 - alpha * A;
                a0 = 1 + alpha / A;
                a1 = -2 * cosWc;
                a2 = 1 - alpha / A;
            } else if (filter.type === 'lowshelf') {
                const sqrt2A = 2 * Math.sqrt(A) * alpha;
                b0 = A * ((A + 1) - (A - 1) * cosWc + sqrt2A);
                b1 = 2 * A * ((A - 1) - (A + 1) * cosWc);
                b2 = A * ((A + 1) - (A - 1) * cosWc - sqrt2A);
                a0 = (A + 1) + (A - 1) * cosWc + sqrt2A;
                a1 = -2 * ((A - 1) + (A + 1) * cosWc);
                a2 = (A + 1) + (A - 1) * cosWc - sqrt2A;
            } else if (filter.type === 'highshelf') {
                const sqrt2A = 2 * Math.sqrt(A) * alpha;
                b0 = A * ((A + 1) + (A - 1) * cosWc + sqrt2A);
                b1 = -2 * A * ((A - 1) + (A + 1) * cosWc);
                b2 = A * ((A + 1) + (A - 1) * cosWc - sqrt2A);
                a0 = (A + 1) - (A - 1) * cosWc + sqrt2A;
                a1 = 2 * ((A - 1) - (A + 1) * cosWc);
                a2 = (A + 1) - (A - 1) * cosWc - sqrt2A;
            } else {
                return 0;
            }
            
            // Normalize coefficients
            b0 /= a0; b1 /= a0; b2 /= a0;
            a1 /= a0; a2 /= a0;
            
            // Calculate frequency response
            // Using Euler's formula: e^(jx) = cos(x) + j*sin(x)
            const ejw_real = Math.cos(-w);
            const ejw_imag = Math.sin(-w);
            const ejw2_real = Math.cos(-2*w);
            const ejw2_imag = Math.sin(-2*w);
            
            // Numerator: b0 + b1*z^(-1) + b2*z^(-2)
            const num_real = b0 + b1 * ejw_real + b2 * ejw2_real;
            const num_imag = b1 * ejw_imag + b2 * ejw2_imag;
            
            // Denominator: 1 + a1*z^(-1) + a2*z^(-2)
            const den_real = 1 + a1 * ejw_real + a2 * ejw2_real;
            const den_imag = a1 * ejw_imag + a2 * ejw2_imag;
            
            // Complex division: (a + bi) / (c + di) = ((ac + bd) + (bc - ad)i) / (c² + d²)
            const den_mag_sq = den_real * den_real + den_imag * den_imag;
            const h_real = (num_real * den_real + num_imag * den_imag) / den_mag_sq;
            const h_imag = (num_imag * den_real - num_real * den_imag) / den_mag_sq;
            
            // Convert to dB
            const magnitude = Math.sqrt(h_real * h_real + h_imag * h_imag);
            return 20 * Math.log10(magnitude);
        }
        
        // Generate logarithmically spaced frequencies
        function logspace(start, stop, num) {
            const logStart = Math.log10(start);
            const logStop = Math.log10(stop);
            const step = (logStop - logStart) / (num - 1);
            
            const result = new Float64Array(num);
            for (let i = 0; i < num; i++) {
                result[i] = Math.pow(10, logStart + i * step);
            }
            return result;
        }
        
        // Calculate target response from PEQ filters
        function calculateTargetResponse(frequencies, fs) {
            const response = new Float64Array(frequencies.length);
            
            // Get settings
            const useFilePreamp = document.getElementById('filePreamp').checked;
            const useAutoPreamp = document.getElementById('autoPreamp').checked;
            
            // Find preamp value
            let filePreamp = 0;
            const preampFilter = peqFilters.find(f => f.type === 'preamp');
            if (preampFilter && useFilePreamp) {
                filePreamp = preampFilter.gain;
            }
            
            // Calculate cumulative response
            for (let i = 0; i < frequencies.length; i++) {
                const freq = frequencies[i];
                let totalGain = 0;
                
                // Sum all filter contributions
                for (let filter of peqFilters) {
                    if (filter.type !== 'preamp') {
                        totalGain += calculateFilterGain(filter, freq, fs);
                    }
                }
                
                response[i] = totalGain;
            }
            
            // Apply file preamp
            if (filePreamp !== 0) {
                for (let i = 0; i < response.length; i++) {
                    response[i] += filePreamp;
                }
            }
            
            // Apply auto preamp to prevent clipping
            if (useAutoPreamp) {
                const maxGain = Math.max(...response);
                if (maxGain > 0) {
                    for (let i = 0; i < response.length; i++) {
                        response[i] -= maxGain;
                    }
                }
            }
            
            return response;
        }
        
        // File input handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const textarea = document.getElementById('peqEditor');
                    textarea.value = event.target.result;
                    updateStatus('File loaded: ' + file.name, 'ready');
                    console.log('File loaded:', file.name);
                };
                reader.readAsText(file);
            }
        });
        
        function clearEditor() {
            const textarea = document.getElementById('peqEditor');
            textarea.value = '';
            peqFilters = [];
            updateStatus('Editor cleared', 'ready');
            if (chart) {
                chart.destroy();
                chart = null;
            }
            console.log('Editor cleared');
        }
        
        function updateStatus(message, type = 'ready') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status-' + type;
        }
        
        function parsePEQ() {
            const content = document.getElementById('peqEditor').value;
            peqFilters = [];
            
            const lines = content.split('\n');
            for (let line of lines) {
                line = line.trim();
                if (!line || line.startsWith('#')) continue;
                
                // Parse Preamp
                if (line.startsWith('Preamp:')) {
                    const parts = line.split(/\s+/);
                    if (parts.length >= 2) {
                        peqFilters.push({
                            type: 'preamp',
                            gain: parseFloat(parts[1])
                        });
                    }
                    continue;
                }
                
                // Parse AutoEQ format
                if (line.startsWith('Filter')) {
                    const parts = line.split(/\s+/);
                    if (parts.length >= 9 && parts[2] === 'ON') {
                        let filter = {
                            type: parts[3].toLowerCase(),
                            freq: parseFloat(parts[5]),
                            gain: parseFloat(parts[8]),
                            q: parts.length > 11 ? parseFloat(parts[11]) : 0.707
                        };
                        
                        // Map types
                        if (filter.type === 'pk') filter.type = 'peaking';
                        else if (filter.type === 'hs') filter.type = 'highshelf';
                        else if (filter.type === 'ls') filter.type = 'lowshelf';
                        
                        peqFilters.push(filter);
                    }
                }
            }
            
            if (peqFilters.length > 0) {
                updateStatus(`Parsed ${peqFilters.length} filters`, 'ready');
                previewResponse();
            } else {
                updateStatus('No valid PEQ filters found', 'error');
            }
        }
        
        function previewResponse() {
            const frequencies = logspace(20, 24000, 500);
            const response = calculateTargetResponse(frequencies, 48000);
            
            // Draw chart
            drawChart(frequencies, response);
        }
        
        function drawChart(frequencies, response, actualResponse = null) {
            const ctx = document.getElementById('chart').getContext('2d');
            
            if (chart) {
                chart.destroy();
            }
            
            const datasets = [{
                label: 'Target Response',
                data: response,
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.1
            }];
            
            if (actualResponse) {
                datasets.push({
                    label: 'Actual FIR Response',
                    data: actualResponse,
                    borderColor: 'rgb(255, 99, 132)',
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                });
            }
            
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: frequencies,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Frequency Response'
                        },
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        x: {
                            type: 'logarithmic',
                            title: {
                                display: true,
                                text: 'Frequency (Hz)'
                            },
                            min: 20,
                            max: 20000
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Magnitude (dB)'
                            }
                        }
                    }
                }
            });
        }
        
        async function convertToFIR() {
            if (peqFilters.length === 0) {
                parsePEQ();
                if (peqFilters.length === 0) {
                    return;
                }
            }
            
            updateStatus('Converting to FIR...', 'processing');
            
            // Get settings
            const numTaps = parseInt(document.querySelector('input[name="taps"]:checked').value);
            const phaseType = document.querySelector('input[name="phase"]:checked').value;
            const bitDepth = parseInt(document.querySelector('input[name="bitdepth"]:checked').value);
            
            firResults = {};
            
            // Convert for both sample rates
            const sampleRates = [44100, 48000];
            
            setTimeout(() => {
                try {
                    for (let fs of sampleRates) {
                        const fir = createFIRFilter(fs, numTaps, phaseType);
                        firResults[fs] = {
                            coefficients: fir,
                            sampleRate: fs,
                            numTaps: numTaps,
                            phaseType: phaseType,
                            bitDepth: bitDepth
                        };
                    }
                    
                    updateStatus('Conversion completed!', 'ready');
                    showDownloadButtons();
                    
                    // Update chart to show actual FIR response
                    const result = firResults[48000];
                    const { w, H } = freqz(result.coefficients, 1024, 48000);
                    const actualDb = H.map(h => 20 * Math.log10(h.magnitude));
                    
                    // Redraw with both responses
                    const targetFreqs = logspace(20, 24000, 500);
                    const targetResponse = calculateTargetResponse(targetFreqs, 48000);
                    
                    // Interpolate actual response to match target frequencies
                    const actualInterp = new Float64Array(targetFreqs.length);
                    for (let i = 0; i < targetFreqs.length; i++) {
                        actualInterp[i] = linearInterp(w, actualDb, targetFreqs[i]);
                    }
                    
                    drawChart(targetFreqs, targetResponse, actualInterp);
                    
                } catch (error) {
                    updateStatus('Error: ' + error.message, 'error');
                    console.error(error);
                }
            }, 100);
        }
        
        function createFIRFilter(fs, numTaps, phaseType) {
            // Create target gains object for key frequencies
            const targetGains = {};
            const keyFreqs = logspace(20, fs/2, 500);
            
            for (let freq of keyFreqs) {
                const responseDb = calculateTargetResponse([freq], fs)[0];
                targetGains[freq] = Math.pow(10, responseDb / 20);
            }
            
            // Design the FIR filter
            const fir = designFIR(targetGains, fs, numTaps);
            
            // TODO: Implement minimum phase conversion if needed
            if (phaseType === 'minimum') {
                console.log('Minimum phase conversion not implemented in this version');
            }
            
            return fir;
        }
        
        // Calculate phase linearity metrics
        function calculatePhaseMetrics(fir) {
            const N = fir.length;
            const center = Math.floor((N - 1) / 2);
            
            // 1. Symmetry error
            let symmetryError = 0;
            for (let i = 0; i < center; i++) {
                const diff = fir[i] - fir[N - 1 - i];
                symmetryError += diff * diff;
            }
            symmetryError = symmetryError / center;
            
            // 2. Impulse peak location
            let maxVal = 0;
            let peakIdx = 0;
            for (let i = 0; i < N; i++) {
                if (Math.abs(fir[i]) > maxVal) {
                    maxVal = Math.abs(fir[i]);
                    peakIdx = i;
                }
            }
            const peakOffset = peakIdx - center;
            
            // 3. Simple phase linearity check
            const isLinearPhase = symmetryError < 1e-10 && Math.abs(peakOffset) < 2;
            
            return {
                symmetryError: symmetryError.toExponential(3),
                peakOffset: peakOffset,
                isLinearPhase: isLinearPhase,
                phaseType: isLinearPhase ? 'Linear Phase' : 'Non-linear Phase'
            };
        }
        
        function showDownloadButtons() {
            const section = document.getElementById('downloadSection');
            const buttons = document.getElementById('downloadButtons');
            
            buttons.innerHTML = '';
            
            // Remove any existing phase info
            const existingPhaseInfo = section.querySelector('.phase-analysis');
            if (existingPhaseInfo) {
                existingPhaseInfo.remove();
            }
            
            // Add phase analysis info
            const phaseInfo = document.createElement('div');
            phaseInfo.className = 'phase-analysis';
            phaseInfo.style.marginBottom = '15px';
            phaseInfo.style.fontSize = '14px';
            phaseInfo.innerHTML = '<h4>Phase Analysis:</h4>';
            
            for (let fs in firResults) {
                const result = firResults[fs];
                const metrics = calculatePhaseMetrics(result.coefficients);
                
                phaseInfo.innerHTML += `<p><strong>${fs}Hz:</strong> ${metrics.phaseType} ` +
                    `(Symmetry Error: ${metrics.symmetryError}, ` +
                    `Peak Offset: ${metrics.peakOffset} samples)</p>`;
                
                const filename = `FIR_${result.phaseType}_${result.numTaps}taps_${fs}Hz`;
                
                // Add phase analysis explanation
                if (fs === '48000') { // Add explanation after last result
                    phaseInfo.innerHTML += `
                    <div style="margin-top: 15px; padding: 15px; background: #e8f4f8; border-radius: 5px; font-size: 13px;">
                        <h5 style="margin-bottom: 10px;">Understanding Phase Analysis:</h5>
                        <ul style="text-align: left; margin-left: 20px;">
                            <li><strong>Linear Phase:</strong> The filter has no phase distortion. All frequencies are delayed by the same amount.</li>
                            <li><strong>Symmetry Error:</strong> Measures how symmetric the impulse response is. Values < 1e-10 indicate perfect linear phase.</li>
                            <li><strong>Peak Offset:</strong> Shows where the impulse response peak is located relative to the center. Should be 0 or ±1 for linear phase.</li>
                            <li><strong>Criteria for Linear Phase:</strong> Symmetry Error < 1e-10 AND Peak Offset < 2 samples</li>
                        </ul>
                    </div>`;
                }
                
                // WAV button
                const wavBtn = document.createElement('button');
                wavBtn.className = 'btn btn-primary download-btn';
                wavBtn.textContent = `${filename}.wav`;
                wavBtn.onclick = () => downloadWAV(result, filename);
                buttons.appendChild(wavBtn);
                
                // TXT button
                const txtBtn = document.createElement('button');
                txtBtn.className = 'btn btn-secondary download-btn';
                txtBtn.textContent = `${filename}.txt`;
                txtBtn.onclick = () => downloadTXT(result, filename);
                buttons.appendChild(txtBtn);
            }
            
            section.insertBefore(phaseInfo, buttons);
            section.style.display = 'block';
        }
        
        function downloadWAV(result, filename) {
            const buffer = createWAVBuffer(result.coefficients, result.sampleRate, result.bitDepth);
            downloadFile(buffer, filename + '.wav', 'audio/wav');
        }
        
        function downloadTXT(result, filename) {
            let content = `# FIR Filter Coefficients\n`;
            content += `# Sample Rate: ${result.sampleRate} Hz\n`;
            content += `# Taps: ${result.numTaps}\n`;
            content += `# Phase Type: ${result.phaseType}\n\n`;
            
            for (let i = 0; i < result.coefficients.length; i++) {
                content += result.coefficients[i].toExponential(10) + '\n';
            }
            
            const blob = new Blob([content], { type: 'text/plain' });
            downloadFile(blob, filename + '.txt', 'text/plain');
        }
        
        function createWAVBuffer(samples, sampleRate, bitDepth) {
            const length = samples.length;
            const arrayBuffer = new ArrayBuffer(44 + length * (bitDepth / 8));
            const view = new DataView(arrayBuffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * (bitDepth / 8), true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, bitDepth === 32 ? 3 : 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * (bitDepth / 8), true);
            view.setUint16(32, bitDepth / 8, true);
            view.setUint16(34, bitDepth, true);
            writeString(36, 'data');
            view.setUint32(40, length * (bitDepth / 8), true);
            
            // Write samples
            let offset = 44;
            for (let i = 0; i < length; i++) {
                const sample = samples[i];
                
                if (bitDepth === 16) {
                    view.setInt16(offset, Math.max(-32768, Math.min(32767, Math.round(sample * 32767))), true);
                    offset += 2;
                } else if (bitDepth === 24) {
                    const value = Math.max(-8388608, Math.min(8388607, Math.round(sample * 8388607)));
                    view.setUint8(offset, value & 0xFF);
                    view.setUint8(offset + 1, (value >> 8) & 0xFF);
                    view.setUint8(offset + 2, (value >> 16) & 0xFF);
                    offset += 3;
                } else { // 32-bit float
                    view.setFloat32(offset, sample, true);
                    offset += 4;
                }
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }
        
        function downloadFile(blob, filename, mimeType) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', function() {
            // Verify elements exist
            const fileInput = document.getElementById('fileInput');
            const peqEditor = document.getElementById('peqEditor');
            const clearBtn = document.querySelector('button[onclick="clearEditor()"]');
            const parseBtn = document.querySelector('button[onclick="parsePEQ()"]');
            
            console.log('Elements found:', {
                fileInput: !!fileInput,
                peqEditor: !!peqEditor,
                clearBtn: !!clearBtn,
                parseBtn: !!parseBtn
            });
            
            // Parse initial content
            parsePEQ();
        });
    </script>
</body>
</html>